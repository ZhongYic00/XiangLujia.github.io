<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="XLJ"><meta name="description" conauthortent="laji OIer"><link rel="alternative" href="/atom.xml" title="XLJ's blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><title>Manacher算法学习笔记 - XLJ's blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">XLJ's blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ（目录）</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://xianglujia.github.io/2017/07/18/About/">について（关于）</a></li><li class="head-nav__item"><a class="head-nav__link" href="https://xianglujia.github.io/2017/07/19/友链/">友達（友链）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-07-18T08:43:13.226Z">July 18, 2017</time><h1 class="post__title"><a href="/2017/07/18/Manacher算法/">Manacher算法学习笔记</a></h1><div class="post__main echo"><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>Manacher 算法 又名 ==<strong>马拉车算法</strong>==</p>
<p>也是回文自动机</p>
<p>此算法专门解决求回文串的问题</p>
<p>求回文串的问题 <strong>首先有暴力做法</strong></p>
<h2 id="1-Brute-force-解法"><a href="#1-Brute-force-解法" class="headerlink" title="1. Brute-force 解法"></a>1. Brute-force 解法</h2><p>枚举每一个子串 判断是否回文 </p>
<p>此方法当然是最好想到的暴力</p>
<p>但是时间复杂度显然是O(n^3)的  </p>
<p>明显数据稍微大一点就不可过</p>
<h2 id="2-Brute-force-优化版"><a href="#2-Brute-force-优化版" class="headerlink" title="2. Brute-force 优化版"></a>2. Brute-force 优化版</h2><p>此时枚举每个中点</p>
<p>向左右扩展 </p>
<p>奇数个和偶数个分开讨论</p>
<p>此时的时间复杂度为O(n^2)的</p>
<p>那么怎么样才可以以O(n)的时间算出回文子串呢</p>
<p>这就需要manacher算法了</p>
<h2 id="3-Manacher"><a href="#3-Manacher" class="headerlink" title="3.Manacher"></a>3.Manacher</h2><p>首先的第一步 </p>
<p>为解决奇数和偶数回文的问题</p>
<p>那么在每个字符之间加上一个’#’’</p>
<h3 id="借鉴hamsterwk的博客-以下内容转自博客"><a href="#借鉴hamsterwk的博客-以下内容转自博客" class="headerlink" title="借鉴hamsterwk的博客:以下内容转自博客"></a><a href="https://hamsterwk.github.io/2017/05/04/manacher%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">借鉴hamsterwk的博客:以下内容转自博客</a></h3><blockquote>
<h3 id="manacher算法，就是在上面O-n2-O-n2-的算法基础上，进行优化，使复杂度变为O-n-O-n"><a href="#manacher算法，就是在上面O-n2-O-n2-的算法基础上，进行优化，使复杂度变为O-n-O-n" class="headerlink" title="manacher算法，就是在上面O(n2)O(n2)的算法基础上，进行优化，使复杂度变为O(n)O(n)."></a>manacher算法，就是在上面O(n2)O(n2)的算法基础上，进行优化，使复杂度变为O(n)O(n).</h3><h3 id="它的主要优化在于：利用之前得到的回文串计算结果，来减少比对次数。"><a href="#它的主要优化在于：利用之前得到的回文串计算结果，来减少比对次数。" class="headerlink" title="它的主要优化在于：利用之前得到的回文串计算结果，来减少比对次数。"></a>它的主要优化在于：利用之前得到的回文串计算结果，来减少比对次数。</h3><h3 id="为实现此算法，我们额外维护两个数值："><a href="#为实现此算法，我们额外维护两个数值：" class="headerlink" title="为实现此算法，我们额外维护两个数值："></a>为实现此算法，我们额外维护两个数值：</h3><h3 id="MaxRightMaxRight-之前发现的回文串中，右端延伸到的位置最远的那个串延伸到的位置。"><a href="#MaxRightMaxRight-之前发现的回文串中，右端延伸到的位置最远的那个串延伸到的位置。" class="headerlink" title="MaxRightMaxRight:之前发现的回文串中，右端延伸到的位置最远的那个串延伸到的位置。"></a>MaxRightMaxRight:之前发现的回文串中，右端延伸到的位置最远的那个串延伸到的位置。</h3><h3 id="pospos-这个回文串的中心所在位置。"><a href="#pospos-这个回文串的中心所在位置。" class="headerlink" title="pospos:这个回文串的中心所在位置。"></a>pospos:这个回文串的中心所在位置。</h3><h3 id="然后，在枚举中心的位置基础上，我们通过一些分析，来定义lenxlen-gt-x的初值。"><a href="#然后，在枚举中心的位置基础上，我们通过一些分析，来定义lenxlen-gt-x的初值。" class="headerlink" title="然后，在枚举中心的位置基础上，我们通过一些分析，来定义lenxlen&gt;x的初值。"></a>然后，在枚举中心的位置基础上，我们通过一些分析，来定义lenxlen&gt;x的初值。</h3><h3 id="这就是manacher的具体原理，在上面那个框架的基础上，加入对lenxlenx的初值定义，减少计算次数。"><a href="#这就是manacher的具体原理，在上面那个框架的基础上，加入对lenxlenx的初值定义，减少计算次数。" class="headerlink" title="这就是manacher的具体原理，在上面那个框架的基础上，加入对lenxlenx的初值定义，减少计算次数。"></a>这就是manacher的具体原理，在上面那个框架的基础上，加入对lenxlenx的初值定义，减少计算次数。</h3></blockquote>
<h2 id="考虑以下情况："><a href="#考虑以下情况：" class="headerlink" title="考虑以下情况："></a>考虑以下情况：</h2><p>当前位置，在MaxRightMaxRight左侧：</p>
<p>在此情况下，i位置是包含在以pos为中心的回文串中的，我们定义其关于pos的对称点为j。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lenj+i−1≤MaxRightlenj+i−1≤MaxRight</div></pre></td></tr></table></figure>
<p>这种情况如此图所示：<br><img src="https://hamsterwk.github.io/images/manacher/len_j+i-1leqMaxRight.png" alt="这里写图片描述"></p>
<p>绿色部分是j为中心的回文串，而i,j是对称的，所以i为中心的这个与j的回文串对称的子串，也是一个回文串。因此，我们可以直接令leni=lenjleni=lenj。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lenj+i−1&gt;MaxRightlenj+i−1&gt;MaxRight</div></pre></td></tr></table></figure></p>
<p>这种情况如此图所示：<br><img src="https://hamsterwk.github.io/images/manacher/len_j+i-1gtMaxRight.png" alt="这里写图片描述"></p>
<p>由于红串内才保证是回文的，所以，虽然橘色很长，甚至延伸到了外面，但是我们只能取其“在红串中”的回文部分。所以，我们取绿色部分（即<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当前位置，在MaxRightMaxRight右侧：</div><div class="line"></div><div class="line">这个时候，由于其不在回文串中，所以我们必须从头开始进行比较过程，也就是```leni=1leni=1```。</div><div class="line"></div><div class="line">分类讨论之后，就还是按照上述方法，进行拓展。</div><div class="line">拓展结束之后，别忘了更新MaxRight和pos</div><div class="line"></div><div class="line">## 复杂度证明</div><div class="line">还是按照上述情况分析：</div><div class="line"></div><div class="line"></div><div class="line">此情况下，其实不会有任何拓展。。。</div><div class="line">因为如果能拓展，在处理j的时候就做到了。。。</div><div class="line"></div><div class="line"></div><div class="line">此情况下，等于直接从MaxRight处开始向外拓展，拓展一次，MaxRight就会增加一次。</div><div class="line"></div><div class="line">另外的情况下，==相当于把pos移动到当前的i，同时也一定会增加MaxRight。== </div><div class="line">### (Mixright只增不减)</div><div class="line">综上，每次操作，要么增加MaxRight，要么增加pos，两者都小于字符串长度，所以复杂度为O(n)。</div><div class="line">## 代码部分</div></pre></td></tr></table></figure></p>
<p>#include<iostream></iostream></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstdlib></cstdlib></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cmath><br>using namespace std;<br>char tmp[2500];<br>char s[5000];<br>int len[5000];<br>int maxright=-1,pos=0;<br>int L;<br>void pre(){<br>    L=strlen(tmp+1);<br>    L<em>=2;<br>    printf(“%d\n”,L);<br>    for(int i=0;i&lt;=L;i+=2)<br>        s[i]=’#’;<br>    int p=0;<br>    for(int i=1;i&lt;L;i+=2)<br>        s[i]=tmp[++p];<br>        printf(“L=%d\n”,L);<br>    printf(“%s\n”,s);<br>}<br>void manacher(){<br>    for(int i=0;i&lt;=L;i++){<br>        int j=pos</em>2-i;<br>        if(i<maxright) i在maxright左边="" len[i]="min(len[j],maxright-i);" else="" while(i+len[i]-1<="L&&i-len[i]+1">=0&amp;&amp;s[i+len[i]-1]==s[i-len[i]+1])//左右扩<br>            len[i]++;<br>        len[i]–;//while多循环一次<br>        if(i+len[i]-1&gt;=maxright){<br>            maxright=i+len[i]-1;<br>            pos=i;<br>        }<br>        printf(“maxright=%d\n”,maxright);<br>    }<br>}<br>int main(){<br>    scanf(“%s”,tmp+1);<br>    pre();<br>    manacher();<br>    for(int i=0;i&lt;=L;i++)<br>        printf(“%d “,len[i]);<br>    return 0;<br>}<br>```</maxright)></cmath></p>
</div></header></article><div class="comments" id="lv-container" data-id="Wuhan" data-uid="No.3 high school of WISCO"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 XLJ</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>